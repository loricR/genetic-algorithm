initIndiv() -> Individu
Données:
Résultat: liste de bits générée aléatoirement
Lexique:

Algo :

	List l := creer()
	Tant que (longIndiv != 0) Faire
		l = ajoutertq(l,rand()%2)
		longIndiv := longIndiv - 1	
	Fin Tant que


initIndiv_recursif(longIndiv : entier) -> Individu
Données: longIndiv, la longueur souhaitée de la liste de bits
Résultat: liste de bits générée aléatoirement
Lexique:

Algo :

	Si longIndiv == 0 Alors 
		initIndiv_recursif(longIndiv) := creer()
	Sinon
		initIndiv_recursif(longIndiv) := ajoutertt(initIndiv_recursif(longIndiv-1), rand()%2)
	Fsi

	

decodeListe(l : Individu) -> entier
Données: la liste de bits à décoder
Résultat: l'entier correspondant à la liste de bits donnée
Lexique:

Algo :

	Si vide(l) Alors
		decodeList(l) := 0
	Sinon
	    decodeList(l) := val(l) + 2*decodeList(suc(l))
	Fsi
				
				

croiserListes(pCroise : réel, l1 : Individu, l2 : Individu) -> Individu 
Données: pCroise probabilité d'intervertir des éléments des 2 listes, l1 et l2 deux liste de bits
Résultat: l3 la liste de bits caractérisant l'individu résultant des éléments intervertis de l1 et l2
Lexique:
	
Algo :

	Si non(vide(l1)) et non(vide(l2)) Alors
		Si réel aléatoire entre 0 et 1 <= pCroise Alors
			croiserListes(pCroise, l1, l2) = ajoutt(croiserListes(pCroise, suc(l1), suc(l2)), val(l1))
		Sinon
			croiserListes(pCroise, l1, l2) = ajoutt(croiserListes(pCroise, suc(l1), suc(l2)), val(l2))
		Fsi
	Sinon
		croiserListes(pCroise, l1, l2) := creer()
	Fsi
		


qualiteIndiv(l : Individu) -> réel
Données: la liste de bits Individu à calculer sa qualité
Résultat: réel correspondant à la qualité de l'individu donné
Lexique:

Algo :

	qualiteIndiv(l) = - ((decodeList(l->listBits) / (2^(l->longIndiv))) * 2 + 1)^2
	// Aucune idée si on doit faire en sorte que A et B puissent changer & si longIndiv paramètre d'Individu ?