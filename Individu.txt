initIndiv() -> Individu
Données:
Résultat: liste de bits générée aléatoirement
Lexique:

Algo :

initIndiv_recursif() -> Individu
Données:
Résultat: liste de bits générée aléatoirement
Lexique:

Algo :

decodeListe(l : Individu) -> entier
Données: la liste de bits à décoder
Résultat: l'entier correspondant à la liste de bits donnée
Lexique:

Algo :

	Si l est Vide, Alors
		decodeList(l) := 0
	Sinon   Si l->val = 0 Alors
			decodeList(l) := decodeList(l->next)
	        Sinon
			decodeList(l) := 2^compteur(l) + decodeList(l->next)
	        Fsi
	Fsi
				
				

croiserListes(pCroise : réel, l1 : Individu, l2 : Individu) -> Individu 
Données: pCroise probabilité d'intervertir des éléments des 2 listes, l1 et l2 deux liste de bits
Résultat: l3 la liste de bits caractérisant l'individu résultant des éléments intervertis de l1 et l2
Lexique:
	
Algo :

	List l3 := NULL;
	Si l1 et l2 ne sont pas vides, Alors
		Si réel aléatoire entre 0 et 1 <= pCroise Alors
			l3->val := l1->val
			l3->next := croiserListes(pCroise, l1->next, l2->next)
		Sinon
			l3->val := l2->val
			l3->next := croiserListes(pCroise, l1->next, l2->next)
		Fsi
	Sinon
		croiserListes(pCroise, l1, l2) := NULL
	Fsi
		


qualiteIndiv(l : Individu) -> réel
Données: la liste de bits Individu à calculer sa qualité
Résultat: réel correspondant à la qualité de l'individu donné
Lexique:

Algo :

	qualiteIndiv(l) = - ((decodeList(l->listBits) / (2^(l->longIndiv))) * 2 + 1)^2	
	// Aucune idée si on doit faire en sorte que A et B puissent changer & si longIndiv paramètre d'Individu ?







